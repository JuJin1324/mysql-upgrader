# mysql-upgrader

## 쿼리 작성 및 최적화
### SQL 모드
> MySQL 서버의 `sql_mode` 라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다. 
> 해당 설정은 대부분의 쿼리의 작동 방식에 영향을 미치므로 프로젝트 초기에 적용하는 것이 좋다. 운용 중인 애플리케이션에서 `sql_mode` 설정을 변경하는 것은
> 상당히 위험하므로 주의해야 한다.  

### 영문 대소문자 구분
> `lower_case_table_names`: 이 변수를 1로 설정하면 모두 소문자로만 저장되고, MySQL 서버가 대소문자를 구분하지 않게 해준다. 
> 이 설정의 기본값은 0으로, DB 나 테이블명에 대해 대소문자를 구분한다.  

### 날짜
> MySQL 서버에서는 정해진 형태의 날짜 포맷으롶 표기하면 MySQL 서버가 자동으로 DATE 나 DATETIME 값으로 변환하기 때문에 
> 복잡하게 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.  
> 
> DATE 타입은 날짜는 포함하지만 시간은 포함하지 않을 때 사용하는 타입이다.  
> DATE 타입 YYYY-MM-DD 형식으로 입력이 가능하며 '1000-01-01' 부터 '9999-12-31' 까지 입력이 가능하다.  
> 
> DATETIME 타입은 날짜와 시간을 모두 포함할 때 사용하는 타입이다.  
> YYYY-MM-DD HH:MM:SS 형식으로 입력이 가능하며 '1000-01-01 00:00:00' 부터 '9999-12-31 23:59:59' 까지 입력이 가능하다.  
> 
> TIME 타입은 시간에 대한 정보만 담는 타입이다.  
> HH:MM:SS 형식으로 입력이 가능하며 '-838:59:59' 부터 '838:59:59' 까지 입력이 가능하다.  
> 
> TIMESTAMP 타입은 날짜와 시간모두를 포함한 타입이다.  
> 범위로는 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 UTC 까지 표현할 수 있다.  
> 
> DATETIME vs TIMESTAMP  
> DATETIME 은 문자형이고 TIMESTAMP 는 숫자형이다.  
> DATETIME 은 8byte, TIMESTAMP 는 4byte 이다.  
> TIMESTAMP 는 타임존을 기반으로 한다.  
> DATETIME 및 TIMESTAMP 는 뒤에 괄호와 숫자를 붙여서 밀리세컨드를 표시할 수 있으며 최대 6자리까지 표시하여 저장할 수 있다.  

### 불리언
> BOOL 이나 BOOLEAN 이라는 타입이 있지만 사실 이건은 TINYINT 타입에 대한 동의어일 뿐이다.  
> MySQL 은 C/C++ 언어에서 처럼 TRUE 또는 FALSE 같은 불리언 값을 정수로 매핑해서 사용한다(0과 1).  
> 모든 숫자 값이 TRUE 나 FALSE 라는 두 개의 불리언 값으로 매핑되지 않는다는 것은 혼란스럽고 애플리케이션의 버그로 연결됐을 가능성이 크다. 
> 불리언 타입을 꼭 사용하고 싶다면 ENUM 타입으로 관리하는 것이 조금 더 명확하고 실수할 가능성도 줄일 수 있다.  

### LIKE 연산자
> LIKE 연산자는 인덱스를 이용해 처리할 수 있다.(와일드카드를 오른쪽에만 넣은 경우)  

### BETWEEN 연산자
> 크거나 같다 와 작거나 같다를 합친 연산자이다.  
> BETWEEN 을 통한 범위 검색보다는 해당 범위의 값이 적은 경우 IN ()을 통해서 괄호 안에 범위의 값들을 모두 넣어서 동등 비교를 하는 것이 좋다. 
> 범위의 값이 많은 경우 JOIN 후 BETWEEN 을 사용하거나 혹은 IN (subquery) 를 사용한다. 
> IN (subquery)는 실행 시 옵티마이저에 의해 자동으로 JOIN 쿼리로 변경되어 실행된다.  

### IN 연산자
> MySQL 8.0 이전 버전까지는 IN 절에 튜플(레코드)를 사용ㅇ하면 항상 풀 테이블 스캔을 했었다. 
> ```sql
> select * 
> from dept_emp 
> where (dept_no, emp_no) in (('d001', 10017), ('d002', 10144), ('d003', 10054));
> ```
> 위의 예제 쿼리는 IN 절의 상숫값이 단순 스칼라값이 아니라 튜플이 사용됐다. 
> MySQL 8.0 버전부터는 위의 쿼리와 같이 IN 절에 튜플을 그대로 나열해도 인ㄷ게스를 최적으로 사용할 수 있게 개선됐다.  
> 
> NOT IN 의 실행 계획은 인덱스 풀 스캔으로 표시되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는
> 사용할 수 없기 때문이다. 
